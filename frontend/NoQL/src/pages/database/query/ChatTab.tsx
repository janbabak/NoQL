import { CHAT_TAB } from './Constants.ts'
import styles from './Query.module.css'
import { TextField } from '@mui/material'
import { LoadingButton } from '@mui/lab'
import SendRoundedIcon from '@mui/icons-material/SendRounded'
import React, { useEffect, useRef, useState } from 'react'
import databaseApi from '../../../services/api/databaseApi.ts'
import { QueryResponse } from '../../../types/Query.ts'
import { Result } from './Result.tsx'
import { ChatHistory } from './ChatHistory.tsx'
import { ChatHistoryItem, Chat } from '../../../types/Chat.ts'
import { ChatView } from './ChatView.tsx'
import { AxiosResponse } from 'axios'
import { useDispatch, useSelector } from 'react-redux'
import { RootState } from '../../../state/store.ts'
import { addMessage, addMessageAndChangeName, fetchChat } from '../../../state/chat/chatSlice.ts'
import { fetchChatHistory, renameChat } from '../../../state/chat/chatHistorySlice.ts'

interface ChatTabProps {
  databaseId: string,
  tab: number,
  editQueryInConsole: (query: string) => void,
}

export function ChatTab({ databaseId, tab, editQueryInConsole }: ChatTabProps) {

  const NEW_CHAT_NAME: string = 'New chat'
  const CHAT_NAME_MAX_LENGTH: number = 32

  const dispatch = useDispatch()

  const activeChatIndexRedux: number = useSelector((state: RootState) => {
    return state.chatHistoryReducer.activeChatIndex
  })

  const chat: Chat | null = useSelector((state: RootState) => {
    return state.chatReducer.chat
  })

  const chatHistory: ChatHistoryItem[] = useSelector((state: RootState) => {
    return state.chatHistoryReducer.chatHistory
  })

  const chatLoading: boolean = useSelector((state: RootState) => {
    return state.chatReducer.loading
  })

  const [
    queryResult,
    setQueryResult
  ] = useState<QueryResponse | null>(null)

  const [
    queryLoading,
    setQueryLoading
  ] = useState<boolean>(false)

  const [
    pageLoading,
    setPageLoading
  ] = useState<boolean>(false)

  const [
    page,
    setPage
  ] = useState<number>(0)

  const [
    pageSize,
    setPageSize
  ] = useState<number>(10)

  const naturalLanguageQuery: React.MutableRefObject<string> = useRef<string>('')

  // TODO: fix multiple calls
  /**
   * Load chat history, then active chat content, then query the chat for the result.
   * Creates new chat if there isn't any.
   */
  useEffect((): void => {
    const asyncCallsChain = async (): Promise<void> => {
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-expect-error
      let result = await dispatch(fetchChatHistory(databaseId))
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-expect-error
      if (result.payload.length > 0) {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-expect-error
        result = await dispatch(fetchChat(result.payload[0].id))
      } else {
      // TODO: create chat
        console.log('create chat not implemented')
      }
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-expect-error
      if (result.payload.messages.length > 0) {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-expect-error
        void loadQueryLanguageQuery(result.payload.messages[result.payload.messages.length - 1].response)
      } else {
        console.log('not load query result')
      }
    }

    asyncCallsChain()
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [])

  /**
   * Query model using the natural language chat.
   */
  async function queryChat(): Promise<void> {
    setPage(0)
    setQueryLoading(true)
    try {
      const response: AxiosResponse<QueryResponse> = await databaseApi.queryChat(
        databaseId, {
          chatId: chatHistory[activeChatIndexRedux].id,
          // eslint-disable-next-line @typescript-eslint/ban-ts-comment
          // @ts-ignore
          query: naturalLanguageQuery.current.value
        },
        pageSize)

      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      naturalLanguageQuery.current.value = ''
      setQueryResult(response.data)

      // update chat name if it's still the autogenerated name
      if (chat?.name == NEW_CHAT_NAME) {
        const updatedName: string = response.data.chatQueryWithResponse.query.length < CHAT_NAME_MAX_LENGTH
          ? response.data.chatQueryWithResponse.query
          : response.data.chatQueryWithResponse.query.substring(0, CHAT_NAME_MAX_LENGTH)

        dispatch(addMessageAndChangeName({
          message: response.data.chatQueryWithResponse,
          name: updatedName
        }))
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        dispatch(renameChat(updatedName))
      } else {
        dispatch(addMessage(response.data.chatQueryWithResponse))
      }
    } catch (error: unknown) {
      console.log(error) // TODO: handle
    } finally {
      setQueryLoading(false)
    }
  }

  /**
   * Load result when page is changed.
   * @param page new page number (first page index is 0)
   * @param pageSize number of items in the page
   */
  async function onPageChange(page: number, pageSize: number): Promise<void> {
    setPageSize(pageSize)
    setPage(page)

    setPageLoading(true)
    try {
      const response: AxiosResponse<QueryResponse> = await databaseApi.queryQueryLanguageQuery(
        databaseId,
        chat?.messages[chat?.messages.length - 1].response || '',
        page,
        pageSize)

      setQueryResult(response.data)
    } catch (error: unknown) {
      console.log(error) // TODO: handles
    } finally {
      setPageLoading(false)
    }
  }

  /**
   * Fetch result of query language query.
   * @param query in query language
   */
  async function loadQueryLanguageQuery(query: string): Promise<void> {
    setQueryLoading(true)
    try {
      const response: AxiosResponse<QueryResponse> = await databaseApi.queryQueryLanguageQuery(
        databaseId, query, 0, pageSize)
      setPage(0)
      setQueryResult(response.data)
    } catch (error: unknown) {
      console.log(error) // TODO: handles
    } finally {
      setQueryLoading(false)
    }
  }

  /**
   * Load query result of a chat - load it's content and query response.
   * @param chatId chat id
   */
  async function loadChatResult(chatId: string): Promise<void> {
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-expect-error
    const result = await dispatch(fetchChat(chatId)) // TODO: move to chat history
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-expect-error
    if (result.payload.messages.length > 0) {
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-expect-error
      await loadQueryLanguageQuery(result.payload.messages[result.payload.messages.length - 1].response)
    } else {
      setQueryResult(null)
    }
  }

  return (
    <div
      role="tabpanel"
      hidden={tab != CHAT_TAB}
      className={styles.chatTab}
    >
      <div className={styles.chatTabContainer}>
        <ChatHistory
          loadChatResult={loadChatResult}
          databaseId={databaseId}
          setQueryResult={setQueryResult}
        />

        <div className={styles.chatWithInput}>

          <ChatView chat={chat} chatLoading={chatLoading} />

          <div className={styles.chatInputContainer}>
            <TextField
              id="query"
              label="Query"
              variant="standard"
              inputRef={naturalLanguageQuery}
              fullWidth
            />

            <LoadingButton
              loading={queryLoading}
              variant="contained"
              endIcon={<SendRoundedIcon />}
              onClick={queryChat}
            >
              Query
            </LoadingButton>
          </div>
        </div>
      </div>

      <Result
        queryResponse={queryResult}
        editQueryInConsole={editQueryInConsole}
        showEditInConsoleButton={true}
        page={page}
        pageSize={pageSize}
        setPageSize={setPageSize}
        totalCount={queryResult?.totalCount || 1}
        onPageChange={onPageChange}
        loading={queryLoading || pageLoading}
      />

    </div>
  )
}