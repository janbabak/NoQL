import { CHAT_TAB } from '../Constants.ts'
import styles from '../Query.module.css'
import { TextField } from '@mui/material'
import { LoadingButton } from '@mui/lab'
import SendRoundedIcon from '@mui/icons-material/SendRounded'
import React, { memo, useEffect, useRef, useState } from 'react'
import databaseApi from '../../../../services/api/databaseApi.ts'
import { ChatHistory } from './ChatHistory.tsx'
import { ChatHistoryItem, Chat, ChatResponse } from '../../../../types/Chat.ts'
import { AxiosResponse } from 'axios'
import { useDispatch, useSelector } from 'react-redux'
import { AppDispatch, RootState } from '../../../../state/store.ts'
import { addMessage, addMessageAndChangeName, fetchChat, setChatToNull } from '../../../../state/chat/chatSlice.ts'
import { fetchChatHistory, renameChat } from '../../../../state/chat/chatHistorySlice.ts'
import { ModelSelect } from './chat/ModelSelect.tsx'
import { showErrorWithMessageAndError } from '../../../../components/snackbar/GlobalSnackbar.helpers.ts'
import { User } from '../../../../types/Authentication.ts'
import { localStorageService } from '../../../../services/LocalStorageService.ts'
import userApi from '../../../../services/api/userApi.ts'
import { ChatView } from './chat/ChatView.tsx'

interface ChatTabProps {
  databaseId: string,
  tab: number,
}

/**
 * Tab with chat input and chat history.
 */
const ChatTab = memo(({ databaseId, tab }: ChatTabProps) => {

  const NEW_CHAT_NAME: string = 'New chat'
  const CHAT_NAME_MAX_LENGTH: number = 32

  const dispatch: AppDispatch = useDispatch()

  const activeChatIndex: number = useSelector((state: RootState) => {
    return state.chatHistoryReducer.activeChatIndex
  })

  const chat: Chat | null = useSelector((state: RootState) => {
    return state.chatReducer.chatNew
  })

  const chatHistory: ChatHistoryItem[] = useSelector((state: RootState) => {
    return state.chatHistoryReducer.chatHistory
  })

  const [
    queryLoading,
    setQueryLoading
  ] = useState<boolean>(false)

  const [
    model,
    setModel
  ] = useState<string>('gpt-4o')

  const [
    user,
    setUser
  ] = useState<User | null>(null)

  const [
    userLoading,
    setUserLoading
  ] = useState<boolean>(false)

  const naturalLanguageQuery: React.MutableRefObject<string> = useRef<string>('')

  // TODO: fix multiple calls
  useEffect((): void => {
    void loadUser()
    void loadChatHistoryAndFetchChat(0)
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [])

  /**
   * Load chat history, then active chat content, then query the chat for the result.
   * Creates new chat if there isn't any. // TODO: that
   */
  async function loadChatHistoryAndFetchChat(chatIndex: number): Promise<void> {
    // chat history
    const result = await dispatch(fetchChatHistory(databaseId))

    // @ts-ignore
    if (result.payload.length > chatIndex && chatIndex >= 0) {
      // @ts-ignore
      await dispatch(fetchChat(result.payload[chatIndex].id))
    } else {
      dispatch(setChatToNull())
      return
    }
  }

  async function loadUser(): Promise<void> {
    setUserLoading(true)
    try {
      const response = await userApi.getById(localStorageService.getUserId() || '')
      setUser(response.data)
    } catch (error: unknown) {
      showErrorWithMessageAndError(dispatch, 'Failed to load user', error)
    } finally {
      setUserLoading(false)
    }
  }

  /**
   * Query model using the natural language chat.
   */
  async function queryChat(): Promise<void> {
    setQueryLoading(true)
    try {
      const response: AxiosResponse<ChatResponse> = await databaseApi.queryChat(
        databaseId, {
          // @ts-ignore
          query: naturalLanguageQuery.current.value,
          model: model
        },
        chatHistory[activeChatIndex].id,
        10)

      // @ts-ignore
      naturalLanguageQuery.current.value = ''

      decrementQueryLimit()

      // update chat name if it's still the autogenerated name
      if (chat?.name == NEW_CHAT_NAME) {
        const updatedName: string = response.data.nlQuery.length < CHAT_NAME_MAX_LENGTH
          ? response.data.nlQuery
          : response.data.nlQuery.substring(0, CHAT_NAME_MAX_LENGTH)

        dispatch(addMessageAndChangeName({
          message: response.data,
          name: updatedName
        }))
        dispatch(renameChat({
          index: activeChatIndex,
          name: updatedName
        }))
      } else {
        dispatch(addMessage(response.data))
      }
    } catch (error: unknown) {
      showErrorWithMessageAndError(dispatch, 'Failed to execute query', error)
    } finally {
      setQueryLoading(false)
    }
  }


  /**
   * Load chat by id.
   * @param chatId chat id
   */
  async function loadChat(chatId: string): Promise<void> {
    await dispatch(fetchChat(chatId)) // TODO: move to chat history
  }

  /**
   * Decrement user's query limit.
   */
  function decrementQueryLimit(): void {
    setUser({
      ...user,
      queryLimit: user?.queryLimit != undefined ? user.queryLimit - 1 : 0
    } as User | null)
  }

  const QueryLimit =
    <div
      className={styles.queryLimit}
      style={user && user.queryLimit != undefined && user?.queryLimit <= 0
        ? { background: '#ff6565' }
        : {}}
    >
      Queries left: {userLoading ? '?' : user?.queryLimit}
    </div>

  return (
    <div
      role="tabpanel"
      hidden={tab != CHAT_TAB}
      className={styles.chatTab}
    >
      <div className={styles.chatTabContainer}>
        <ChatHistory
          loadChat={loadChat}
          loadChatHistoryAndChatAndResult={loadChatHistoryAndFetchChat}
          databaseId={databaseId}
        />

        <div className={styles.chatWithInput}>

          <div className={styles.modelSelectQueryLimitContainer}>
            <ModelSelect model={model} setModel={setModel} />
            {QueryLimit}
          </div>

          <ChatView />

          <div className={styles.chatInputContainer}>
            <TextField
              id="query"
              label="Query"
              variant="standard"
              inputRef={naturalLanguageQuery}
              fullWidth
            />

            <LoadingButton
              loading={queryLoading}
              variant="contained"
              endIcon={<SendRoundedIcon />}
              onClick={queryChat}
              disabled={user?.queryLimit == undefined || user.queryLimit <= 0}
            >
              Query
            </LoadingButton>
          </div>
        </div>
      </div>
    </div>
  )
})

export { ChatTab }