import groovy.xml.XmlSlurper
import org.xml.sax.EntityResolver
import org.xml.sax.InputSource

import javax.xml.parsers.SAXParserFactory

plugins {
	id 'java'
	id 'org.springframework.boot' version '3.2.0'
	id 'io.spring.dependency-management' version '1.1.4'
    id 'jacoco' // test coverage
    id 'pmd' // lint
}

bootRun {
	systemProperty 'app.config.workingDirectory', System.getProperty('user.dir')
}

group = 'com.janbabak'
version = '0.0.18'

repositories {
    mavenCentral()
}

ext {
    docker = [
        repo: 'janbabak',
        plotServiceVersion: '0.0.3',
        buildScriptPath: "${rootDir}/../infra/scripts/build-image.sh"
    ]
}

java {
	sourceCompatibility = JavaVersion.VERSION_17
}

jar {
	enabled = false // not to generate *plain.jar file
}

configurations {
	compileOnly {
		extendsFrom annotationProcessor
	}
}

dependencies {
	implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
	implementation 'org.springframework.boot:spring-boot-starter-web'
	implementation 'org.springframework.boot:spring-boot-starter-validation:3.2.2'
	implementation 'org.springframework.boot:spring-boot-starter-security:3.4.2' // latest version (26. 1. 2025)
	implementation 'io.jsonwebtoken:jjwt:0.12.6'
	implementation 'io.jsonwebtoken:jjwt-api:0.12.6'
	implementation 'io.jsonwebtoken:jjwt-impl:0.12.6'
	implementation 'io.jsonwebtoken:jjwt-jackson:0.12.6'
	implementation 'org.json:json:20240303'
    implementation 'dev.langchain4j:langchain4j:1.9.1'
    implementation 'dev.langchain4j:langchain4j-open-ai:1.9.1'
    implementation 'dev.langchain4j:langchain4j-open-ai-spring-boot-starter:1.9.1-beta17'
    implementation 'dev.langchain4j:langchain4j-google-ai-gemini:1.9.1'
    implementation 'dev.langchain4j:langchain4j-anthropic:1.9.1'
    implementation 'mysql:mysql-connector-java:8.0.33' // latest version (26. 1. 2025)

	runtimeOnly 'org.postgresql:postgresql:42.7.3'
	compileOnly 'org.projectlombok:lombok'
	annotationProcessor 'org.projectlombok:lombok'
    testCompileOnly 'org.projectlombok:lombok'
    testAnnotationProcessor 'org.projectlombok:lombok'

	developmentOnly 'org.springframework.boot:spring-boot-devtools'

	testImplementation 'org.springframework.boot:spring-boot-starter-test'
	testImplementation 'com.h2database:h2:2.2.224'
	testImplementation "org.testcontainers:junit-jupiter:1.20.4" // latest version (26. 1. 2025)
	testImplementation "org.testcontainers:postgresql:1.19.8"
	testImplementation "org.testcontainers:mysql:1.19.8"
	testImplementation 'org.springframework.security:spring-security-test:6.3.3'

}

// lint
pmd {
    toolVersion = '7.15.0'
    sourceSets = [sourceSets.main, sourceSets.test]
}

tasks.withType(Pmd).configureEach {
    ruleSets = []
}

tasks.named("pmdMain") {
    ruleSetFiles = files("config/pmd/pmd-main.xml")
}

tasks.named("pmdTest") {
    ruleSetFiles = files("config/pmd/pmd-test.xml")
}

tasks.named('test') {
	useJUnitPlatform()

	boolean showLogs = project.hasProperty("showLogs")

	if (showLogs) {
		testLogging {
			// Show standard out and standard error of the test JVM(s) on the console.
			showStandardStreams = true
		}
	}
}

jacocoTestReport {
    description = "Run test with code coverage"

    dependsOn test

    reports {
        xml.required = true
        html.required = true
        csv.required = false
    }
}

tasks.register('computeTotalTestCoverage') {
    dependsOn jacocoTestReport

    // parse jacoco report, compute, and print total test coverage
    doLast {
        def reportFile = layout.buildDirectory.file("reports/jacoco/test/jacocoTestReport.xml").get().asFile
        if (!reportFile.exists()) {
            println "JaCoCo report not found."
            return
        }

        def factory = SAXParserFactory.newInstance()
        factory.setNamespaceAware(true)
        // because there were some issues with DOCTYPE parsing
        factory.setFeature("http://apache.org/xml/features/disallow-doctype-decl", false)
        factory.setFeature("http://xml.org/sax/features/external-general-entities", false)
        factory.setFeature("http://xml.org/sax/features/external-parameter-entities", false)

        def xmlReader = factory.newSAXParser().getXMLReader()

        // Ignore external DTDs
        xmlReader.setEntityResolver(new EntityResolver() {
            InputSource resolveEntity(String publicId, String systemId) {
                return new InputSource(new StringReader(""))
            }
        })

        def slurper = new XmlSlurper(xmlReader)
        def report = slurper.parse(reportFile)

        def counters = report.counter.findAll { it.@type == 'INSTRUCTION' }
        if (counters) {
            def covered = counters[0].@covered.toInteger()
            def missed = counters[0].@missed.toInteger()
            def total = covered + missed
            def coverage = (covered / total * 100).round(2)
            println "${coverage}"
        } else {
            println "No instruction counters found."
        }
    }
}

tasks.register('dockerBuildBackend', Exec) {
    group = "docker"
    description = "Build backend Docker image (push by default, disable with -Ppush=false)"

    dependsOn build

    def imageName = "${docker.repo}/noql-backend"
    def dockerFilePath = "${projectDir}/docker/backend.Dockerfile"
    def pushEnabled = !project.hasProperty("push") || project.property("push") != "false"

    doFirst {
        println "Docker backend image build started: ${imageName}:${project.version}"
        println "Docker push " + pushEnabled ? "ENABLED" : "DISABLED (local build only)"

        if (pushEnabled) {
            commandLine "bash", docker.buildScriptPath, imageName, project.version, dockerFilePath
        } else {
            commandLine "bash", docker.buildScriptPath, imageName, project.version, dockerFilePath, "-x", "push"
        }
    }

    doLast {
        println "Docker backend image built: ${imageName}:${project.version}"
    }
}

tasks.register('dockerBuildPlotService', Exec) {
    group = "docker"
    description = "Build Plot service Docker image (push by default, disable with -Ppush=false)"

	def imageName = "${docker.repo}/noql-plot-service"
    def dockerFilePath = "${projectDir}/docker/plotService.Dockerfile"
    def pushEnabled = !project.hasProperty("push") || project.property("push") != "false"

    doFirst {
        println "Docker plot service image build started: ${imageName}:${docker.plotServiceVersion}"
        println "Docker push " + pushEnabled ? "ENABLED" : "DISABLED (local build only)"
        if (pushEnabled) {
            commandLine "bash", docker.buildScriptPath, imageName, docker.plotServiceVersion, dockerFilePath
        } else {
            commandLine "bash", docker.buildScriptPath, imageName, docker.plotServiceVersion, dockerFilePath, "-x", "push"
        }
    }

    doLast {
        println "Docker plot service image built: ${imageName}:${docker.plotServiceVersion}"
    }
}
